3/31

https://flatsun.tistory.com/2498

디버그 모드 및 테스트 하기

* 점심시간엔 질문하지 않기 * (쉬는 시간임)

면접때 어짜피 다시 가르쳐야한다. 다시 배워야 한다. 라고 하심 걍 맘에 두고 새로 할 기술만 배워가고

기존에 했던 프로젝트들은 어짜피 보면 이해가 가기 때문에 흐름만 파악한다.



개발 하던 과정이

시나리오를 작성한다. 

시나리오대로 개발한다 인데

ex) 센서의 데이터가 이런 방식으로 들어오면 이렇게 받아서 이렇게 가공하고 데이터베이스에 저장 

웹에서는 데이터베이스를 참조 (1초마다? 혹은 좋은 방법이 있다면 선택) 해서 웹에 출력해주기

자바가 그나마 가장 자신있고 가장 최근에 했었기 때문에 보면 이해가 되고 작성도 자바 스프링부트로는 문제없이 할 수 있을 것이다.

repository : DB나 entity 관리
controller : 1. 클라이언트와의 소통 받은 데이터를 Service로 넘겨서 가공처리
service : Repository에서 얻어온 정보를 바탕으로 가공해서 Controller에 정보를 보내기  

데이터가 들어오면 -> controller에서 RestAPI로(PostMapping) 데이터를 받고 (Requestbody로 getter,setter구조로) 처리 및 가공한다. 후 데이터베이스에 저장해야함 ->
entity의 getter, setter 구조로 보내서 값을 받아온 후 -> Service에서 데이터베이스에 저장하는 연산을 작성 후 -> Repository(JPA로)에서 값을 넣는다.
-> DB에 저장완료
 
controller -> Service -> Repository -> DB

String Builder는 동기화 없는 버퍼

String Buffer는 동기화 지원하는 버퍼

개선점 
1. SerialData를 controller로 옮기기
2. SerialData -> restapi를 사용할 필요가 없었네 어짜피 블루투스 시리얼 포트로 들어오니깐 괜히 썼다

SerilaData->restapi->service->repository



HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(map, headers);

            ResponseEntity<Map> responseFromPythonServer =
                    restTemplate.postForEntity(pythonServerUrl, requestEntity, Map.class);

            if (responseFromPythonServer.getStatusCodeValue() == 200) {
                Map<String, Object> responseBody = responseFromPythonServer.getBody();
                System.out.println("R3: " + responseBody.get("Answer").toString());
                return responseBody.get("Answer").toString();

* Hashmap 형태의 Rest API 데이터 송신후 응답 받기 (ex) 챗봇을 사용해서 응답 받아오기 
Java Spring Boot -> Python

 HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        System.out.println(map);
        HttpEntity<String> requestEntity = new HttpEntity<>(jsonData, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(REST_API_SERVER, requestEntity, String.class);
        if (response.getStatusCodeValue() == 200) {
            System.out.println("데이터 전송 성공");
        } else {
            System.out.println("데이터 전송 실패");


ObjectMapper -> Json <-> Java객체로 변환해서 사용


* 같은 패키지 안에 있는 코드로 전송

@Autowired
private AllService allService;

allService.saveAllDB(allStoreData);

컨트롤러에서 데이터를 인자에 할당하는 대표적인 방법으로는 @RequestBody 와 @RequestParam 이 있다.

https://ocblog.tistory.com/49
CRUD시 GET방식은 URL에 포함해서 보내고, POST방식은 HTTP Body에 포함해서 전송한다.

RequestBody는 body에 있는걸 가져오고, RequestParam은 url에 있는걸 가져온다.

url상에서 데이터를 전달하는 경우(form 태그 등) @RequestParam 을 이용하고,

그 외의 경우 @RequestBody 를 이용하자!


협업을 위한 git 사용법
https://sseozytank.tistory.com/41

git add -> git commit -> git push


기존에 맥북으로 사용 
    * 가장 최근 커밋한 지점으로 롤백하기
        * git reflog
        * git reset —hard HEAD^ (HEAD 대신에 소스 입력가능)
        * git commit -m “커밋 메세지”
        * git push -f origin 
* 깃허브 기존 파일 레파지토리 등록
    * 숨김 파일에서 .git 지우기 (숨김파일 보이기 : Shift + Command + . )
    * Git remote -v : 연결된 레파지토리 확인
    * Git remote remove origin : 연결된 레파지토리 지움
    * Git remote add origin (주소)
    * Git add .
    * Git commit -m “메세지 내용”
    * Git push origin master