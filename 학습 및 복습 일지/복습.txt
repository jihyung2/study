추가적인 전공 cs 지식 복습 

DB 커넥션 풀을 5만명이 사용하려고 할 때 각각 하나씩 줘야하는가? 사람들이 들어와서 사용하는가? 질문

세션과 커넥션의 차이를 OSI7계층, idle, 좀비 프로세스와 연관지어서 공부하기

=================================================================================================
Java + Spring 

Servlet이란 : 웹 페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램
Servelt 생명주기 : 클라이언트가 Servlet에 요청을 하면, Servlet은 바로 호출이 되지 않고 객체를 생성하고 초기화 작업을 거친 후, 요청을 처리하는 생명 주기를 가짐
init(초기화) - service(클라이언트 요청 처리) -  destroy(종료)

JSP : HTML 코드 속에 자바 코드가 들어가는 구조의 스크립트 언어

스프링 컨테이너의 생명주기 :
1. ApplicationContext를 이용해서 객체를 생성하고 스프링 컨테이너를 초기화 합니다.
2. getBean()과 같은 메서드를 이용해서 컨테이너에 있는 빈 객체를 사용합니다.
3. close() 메서드를 이용해서 컨테이너를 종료합니다.

Bean이란 : 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트
Bean 객체의 생명주기 : 객체 생성 - 의존 설정 - 초기화 - 소멸

컴포넌트란 : 재사용이 가능한 각각의 독립된 모듈

DB Connection Pool이란 : JDBC API를 사용하여 데이터베이스와 연결하기 위해 Connection 객체를 생성하는 작업은 비용이 굉장히 많이 든다.
DB를 연결할 때마다 Connection 객체를 새로 만드는 것은 비용이 많이 들며, 굉장히 비효율적이다.
*이러한 문제를 해결하기 위해 애플리케이션 로딩 시점에 Connection 객체를 미리 생성하고, 애플리케이션에서 데이터베이스에 연결이 필요한 경우 미리 준비된
Connection 객체를 사용하여 애플리케이션의 성능을 향상하는 커넥션 풀이 등장한다. DB드라이버를 통해 커넥션을 조회, 연결, 인증, SQL을 실행하는 시간 등 커넥션 객체를 생성하기 위한 과정을 생략할 수 있다.
: 웹 컨테이너(WAS)가 실행되면서 DB와 미리 connection(연결)을 해놓은 객체들을 pool에 저장해두었다가.
클라이언트 요청이 오면 connection을 빌려주고, 처리가 끝나면 다시 connection을 반납받아 pool에 저장하는 방식을 말합니다.

Spring Interceptor : https://hudi.blog/spring-handler-interceptor/
	다수의 컨트롤러에 동일한 기능을 제공하기 위해 사용하는 것이 인터셉터이다
	
	preHandle
	컨트롤러 실행 전에 수행

	postHandle
	컨트롤러 수행 후 결과를 뷰로 보내기 전에 수행

	afterCompletion
	뷰의 작업까지 완료된 후 수행
	
HTTP Session - Java 라이브러리

JSSessionID - 서버에서 세션에다가 저장 -> 쿠키에 저장
	
@(어노테이션) 종류 : 
Bean : 개발자가 직접 제어가 불가능한 외부 라이브러리 등을 Bean으로 만드려고 할 때 사용
Interceptor : 
(request) Client -> preHandle -> Server

(response) server -> PostHandler  -> Client

[eclipse]
Ctrl + click -> 파일로 이동

우클릭 + source 후 원하는 내용 클릭 : 단축으로 만들어줌	

=================================================================================================
Vue3 ( 인강 다듣고 내용 정리해서 추가하기 )

Vue3 LifeCycle(Composition API) : onBeforeMounte -> onMounted -> onBeforeUpdate -> onUpdated -> onBeforeUnmounte -> onUnmounted

var = 재선언과 재할당이 가능
let = 재할당 가능, 재선언 불가능
const = 재선언과 재할당 불가능

var x = 10;
let y = 20;
const z = 30;

x = 50; // 재할당 가능
y = 60; // 재할당 가능
z = 70; // TypeError: Assignment to constant variable.

var x = 11; // 재선언 가능
let y = 70; // 재선언 불가능

세션 : 아이디 저장
쿠키 : 자동 로그인

Vue3 인강 수강중 Todo작업 : 배열안에 값을 넣고 웹에 리스트가 추가된 상태에서 새로고침을 하면 순서가 섞인다. -> 로컬스토리지에서 값을 꺼내올 때 정렬이 안되어 있어서 그렇다. 꺼내온 다음 배열에서 sort()를 사용하면 된다.
* 로컬스토리지의 값의 순서가 일관되지 않음

Interface(implements) : 
상속(extends) :
추상(abstract) :

세션 : 서버에서 가지고 있는 정보
쿠키 : 웹에서 가지고 있는 정보

LocalStorage : 

SessionStorage : 

프록시란 : 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 서버
(중계 기능을 하는 서버)

특정 사이트를 가려고 할 때, 가고싶은 목적지 사이트의 주소를 직접 프록시 서버에 전달하며 프록시 서버가 해당 목적지 사이트의 내용을 받아와서 전달해주는 개념

ex) 1. http://example.com이라는 주소의 웹 어플리케이션이 http://api.example.com이라는 리소스에서 데이터를 요청한다.
2. 웹 애플리케이션은 직접적으로 리소스에 요청하는 대신, http://example-proxy.com이라는 프록시 서버에 요청을 보낸다.
3. 프록시 서버가 http://api.example.com으로 요청을 전달하고, 응답을 다시 웹 애플리케이션에 반환한다.
4. 이렇게 하면 요청이 http://example-proxy.com 보내진것 처럼 보이므로 CORS 에러를 피할 수 있다.

CORS(Cross-Origin Resource Sharing) : 다른 출처에서 웹 페이지의 리소스를 요청할 떄, 브라우저가 이를 허용하도록 하는 보안 메커니즘
기본적으로 브라우저에서 한 출처의 스크립트가 다른 출처의 리소스에 접근하는 것을 금지한다. 이 정책을 우회하기 위해 다른 출처로부터 HTTP요청을 허용하거나 거부하는 방법을 정의한다. 
CORS를 사용함으로써 웹 애플리케이션은 안전하게 데이터를 공유하고 상호 작용할 수 있다.

SSR : Server Side Rendering, 서버에서 렌더링하여 완성된 HTML파일을 로드해준다. ex) 클릭하면 새로고침 같은 방식으로 화면 나옴
클라이언트에서 요청할 때마다 각 상황에 맞는 HTML파일을 넘겨주기 떄문에 페이지가 여러개이다. 

CSR : Client Side Rendering, 초기 로드 시 빈 HTML과 모든 로직이 담겨 있는 javascript를 다운로드
자바 스크립트를 사용해서 동적으로 Dom을 그려내기 때문에 원하는 내용만 업데이트 할 수 있다. ex) vue 같은 위에 틀 고정에 내용만 바뀌는식 
ex) 링크 이동을 클릭했을 때, 헤더와 같은 중복되는 내용은 고정으로 두고 콘텐츠만 업데이트 한다.

[JavaScript]
== : 동등 연산자로 서로 값이 같다면 true, 다르다면 false가 된다. 단순히 값만을 비교

=== : 일치 연산자로 좌항과 우항이 정확하게 같을 때 true, 다르면 false가 된다.
ex) 1=='1' true. 1==='1' false
   
[My Batis]
#{} : 파라미터가 String 형태로 들어와 자동적으로 파라미터 형태가 된다. 쿼리 주입 예방 가능 (회사에서 사용)
${} : 파라미터가 바로 출력된다. 해당 컬럼의 자료형에 맞춰 파라미터의 자료형이 변경된다. 쿼리 주입을 예방할 수 없어 보안측면에서 불리하다.

=================================================================================================
컴퓨터 네트워크

ip주소란: P주소란 인터넷 상에서 통신하기 위해 각각의 컴퓨터 및 통신장비에 부여하는 고유한 주소를 의미합니다.

ipv4 : 32비트, 8비트씩 4부분으로 10진수로 표시 A,B,C등 클래스 단위의 주소 할당

ipv6 : 128비트, 16비트씩 8부분으로 16진수로 표시 

NAT : (사설망 생성: 하나의 공인 ip를 여러 개의 사설 ip로 변환하는 시스템)사설 IP와 공인 IP 주소 간에 주소 변환을 수행하여 여러 호스트들이 단일 공인 IP 주소를 공유하며 인터넷을 사용할 수 있도록 해주는 기술
사용목적 : 공인IP주소 절약

고정 ip : 고정 IP는 말 그대로 변하지 않고 컴퓨터에 고정적으로 부여된 IP이다. 한번 부여되면 IP 반납을 하기 전까지는 다른 장비에 부여할 수 없는 고유의 IP로 보안성이 우수하기 때문에 보안이 필요한 업체나 기관에서 사용한다.

유동 ip : 일정한 주기 또는 사용자들이 인터넷에 접속하는 매 순간마다 사용하고 있지 않은 IP 주소를 임시로 발급해 주는 IP이다.

공인 ip :  우리나라는 한국인터넷진흥원(KISA)에서 국내 IP 주소들을 관리, 이것을 ISP(Internet Service Provider의 약자로 KT, LG, SKT와 같이 인터넷을 제공하는 통신업체)가 부여받고, 우리는 위 회사에 가입을 통해 IP를 제공받아 인터넷을 사용하게 되는 것이다. 

사설 ip : 공유기를 사용한 인터넷 접속 환경일 경우 공유기까지는 공인 IP 할당을 하지만, 공유기에 연결되어 있는 가정이나 회사의 각 네트워크 기기에는 사설 IP를 할당한다. 일반 가정이나 회사 내 등에 할당된 네트워크, A,B,C클래스의 주소 대역으로 제공

즉, 공인 IP는 전 세계에서 유일하지만, 사설 IP는 하나의 네트워크 안에서 유일하고
공인 IP는 외부, 내부 상관없이 해당 IP에 접속할 수 있으나, 사설 IP는 내부에서만 접근이 가능

Internet : TCP/IP를 이용하여 전세계 호스트와 상호통신이 가능한 대규모의 네트워크

internet(inter-networks) : 공통 프로토콜을 쓰는 복수의 네트워크를 접속한 것 ( 같은 프로토콜을 쓰며 컴퓨터가 2개 이상 연결된 것 )

Web : 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간

OSI 7계층 : 네트워크에서 통신이 일어나는 과정을 7단계로 나눈것

포트포워딩 : 내부 네트워크의 포트와 인터넷의 포트를 연결시켜 서로 통신할 수있도록 열어주는 것
특정 프로세스(서비스) 또는 기기에 접근하기 위해 포트 포워딩을 통해 외부 아이피 : 특정 포트로 접속하면 내부 아이피 : 특정 포트로 맵핑해준다.

쿠키 : 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일, 필요시 정보를 참조하거나 재사용 가능 ex) 방문했던 사이트에서 다시 방문 했을때 아이디와 비밀번호 자동 입력

세션 : 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다. ex) 화면이 이동해도 로그인이 풀리지 않고 로그아웃 하기전까지 유지
 
=================================================================================================
데이터 통신

커넥션 : DB와 클라이언트 간의 TCP 소켓을 통한 물리적인 연결

세션 : 사용자가 데이터베이스에 연결된 상태를 의미한다. (논리적인 연결)

커넥션을 통한 모든 요청은 세션을 통해서 실행

tibero, oracle 최대 세션 개수 : 100개

=================================================================================================
운영체제

*일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나의 스레드를 갖는다.

공유자원을 사용하는 이유 : 한정된 자원을 효율적으로 사용하기 위해

메모리의 구조 :(low) [Code 영역][데이터 영역][힙 영역][스택 영역] (high)
Code 영역 : 실행할 프로그램의 코드가 저장되는 영역
데이터 영역 : 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역, 프로그램의 시작과 함께 할당되며 종료되면 소멸
힙 영역 : 메모리의 힙 영역은 사용자가 직접 관리할 수 있는 메모리 영역, 실제 데이터가 동적으로 할당 (low->high)
스택 영역 : 메모리의 스택 영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역, 함수의 호출과 함께 할당하며 호출이 완료되면 소멸

프로세스간 통신, IPC(Inter-Process Communication) : 프로세스들 사이에 서로 데이터를 주고 받는 행위

오버헤드 : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 

프로세서(Processor) : CPU 코어

프로그램(Program) : 어떤 작업을 위해 실행할 수 있는 파일

프로세스(Process) : 운영체제로부터 자원을 할당받은 작업의 단위 (프로그램이 돌아가는 상태, 작업중인 프로그램)

스레드(Thread) : 프로세스가 할당받은 자원을 이용하는 실행의 흐름단위 (프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위)

운영 체제의 시스템 자원을 효율적으로 관리하기 위해 스레드 사용

멀티 프로세스 : 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술
* 장점 : 프로그램 안정성 : 각 프로세스가 독립적인 메모리 공간을 가지므로, 한 프로세스가 비정상적으로 종료되어도 다른 프로세스에 영향주지 않음 ex) 웹페이지 탭
* 단점 : Context Switching 과정에서 성능 저하가 올 수 있다, 메모리 사용량 증가
프로세스를 컨텍스트 스위칭 하면, CPU는 다음 프로세스의 정보를 불러오기 위해 메모리를 검색하고, CPU 캐시 메모리를 초기화하며, 프로세스 상태를 저장하고, 불러올 데이터를 준비해야 하기 때문에, 이로 인한 빈번한 Context Switching 작업으로 인해 비용 오버헤드가 발생할 수 있게 된다

멀티 스레드 : 스레드는 하나의 프로세스 내에 있는 실행 흐름이다. 그리고 멀티 스레드는 하나의 프로세스 안에 여러개의 스레드가 있는 것을 말한다. 따라서 하나의 프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능해진다.
ex). 사용자가 서버 데이터베이스에 자료를 요청하는 동안 브라우저의 다른 기능을 이용할 수 있는 이유도 바로 멀티 스레드 기능 
* 장점 : 프로세스보다 가볍다, 공유 메모리에 대해 스레드간 자원 공유가 가능하다. ( 독립적인 메모리 하나를 공유해서 사용 )
* 단점 : 기본적으로 하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료된다. 여러 개의 스레드가 공유자원에 동시에 접근할 수 있기 때문에 동기화 문제가 발생할 수 있다. 

동기화 작업 : 여러 스레드들이 자원에 대한 접근을 순차적으로 통제 하는 것, 그러나 여러 스레드 접근을 제한하는 것이기 대문에 병목 현상이 일어나 성능이 저하될 수 있다.
병목현상을 해결하기 위해 뮤텍스, 세마포어 

병목현상 : 시스템 내에서 전체적인 처리 속도를 떨어뜨리게 되는 특정한 부분

데드락(교착상태) : 다수의 프로세스나 스레드가 서로 자원을 점유하고, 다른 프로세스나 스레드가 점유한 자원을 기다리는 상황에서 발생하는 교착 상태
* 여러개의 스레드가 서로 대기하면서 무한정 기다리게 되는 무한루프와 같은 증상
ex) 스레드 1은 A를 점유한 상태에서 B를 대기, 스레드 2는 B를 점유한 상태에서 A를 대기 -> 무한 루프

임계영역(Critical Section) : 멀티 스레드 프로그래밍에서 임계 영역은 "공유 자원을 접근"하는 코드 영역을 말한다. ( 전역 변수, heap 메모리 영역 )

뮤텍스(Mutex) : 공유 자원에 대한 접근을 제어하기 위한 상호 배제 기법, 임게 영역에 진입하기 전에 락을 획득하고 빠져나올 때 락을 해제하여 다른 스레드들이 접근할 수 있게 한다 ( 1개의 스레드만 접근 가능 )

세마포어(Semaphore) : 동시에 접근 가능한 스레드의 개수를 지정, 스레드가 임계 영역에 진입하기 전에 세마포어 값을 확인하고 값이 허용된 범위 내에 있을때만 락을 획득 ( 뮤텍스 상위 호환 )

Context Switch(문맥 교환) : 문맥 교환은 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)을 보관하고 새로운 프로세스의 상태를 적재하는 작업
* 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록(PCB)에 기록

PCB(Process Control Block) : 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내 자료구조

커널 : 커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 컴퓨터 자원들을 관리하는 역할을 한다. 

인터페이스 : 인터페이스(interface)는 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다.

=================================================================================================
컴퓨터 구조

컴파일 : 인간이 이해할 수 있는 언어로 작성된 코드를 CPU가 이해할 수 있는 형태로 변환 

=================================================================================================
소프트웨어 설계 및 방법론

소프트웨어 생명주기 : 개발과 유지보수 등에 필요한 작업들을 체계적으로 정리한 개발 방법론의 바탕으로서 개발을 위한 정의, 운용, 유지보수 등의 과정을 단계별로 나눈 것 ( 대표적 생명주기 모형 : 폭포수, 프로토타입, 나선형, 애자일 )
계획 - 설계 - 구현 - 테스트 - 배포 - 유지 관리

폭포수 모형 : 이전 단계로 돌아갈 수 없다는 전제를 깔고 각 단게에서 확실하게 진행하여 결과를 검토하고 승안하는 과정을 마친 후 넘어감

프로토타입 모형 : 시제품을 만들어 최종에 완성될 결과물을 예측하는 모델

나선형 모델 : 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐서 점진적으로 결과를 완성하는 것

애자일 모형 : 고객의 요구 사항 변화에 유연하게 대응하는 일정한 주기를 가지고 반복하여 개발하는 모델

=================================================================================================
자료구조

=================================================================================================
알고리즘
https://se-jung-h.tistory.com/entry/CScomputer-science-CS%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0

Bubble Sort(버블 정렬) : 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘
*동작 : 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번쨰 원소를.. 이런 식으로 (N-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다.
이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 늘어난다.
*장점 : 구현이 매우 간단하고, 직관적이다. 정렬하고자 하는 배열안에서 교환하는 방식으로(공간복잡도 O(n), 다른 메모리 공간을 필요로 하지 않는다. 안정 정렬이다.
*단점 : 시간복잡도가 최악, 최선, 평균 모두 O(n^2)로 굉장히 비효율적이다.

Selection Sort(선택 정렬) : Bubble Sor는 값을 찾는 것이다.
*동작 : 주어진 배열 중에 최소값을 찾는다. -> 그 값을 맨 앞에 위치한 값과 교체한다. -> 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.
*장점 : 알고리즘이 단순하다, 정렬을 위한 비교 횟수는 많지만 실제로 교환하는 횟수는 적다., 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다(공간복잡도O(n)).
*단점 : 시간복잡도가 O(n^2)으로 비효율적이다, 불안정 정렬이다.t와 유사한 알고리즘으로, 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

Insertion Sort(삽입 정렬) : Selection Sort와 유사하지만, 좀 더 효율적인 정렬 알고리즘이다. 최선의 경우 O(N)이라는 엄청나게 빠른 효율성을 가지고 있다.
*동작 : 2번째 원소부터 시작해서 그 앞의 원소들과 비교하여 삽입할 위치를 지정한 후 지정된 자리에 자료를 삽입
2번째 위치의 값을 temp에 저장한다. -> temp와 이전에 있는 원소들과 비교하며 삽입해나간다. ->  다음 위치의 값을 temp에 저장하고 반복한다.
*장점 : 알고리즘이 단순하다. 제자리 정렬, 안정 정렬이다. 선택 정렬, 버블 정렬 알고리즘에 비교해서 빠르다.
*단점 : 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다. 배열의 길이가 길어질수록 비효율적이다.

Quick Sort(퀵 정렬) : 분할 정복 방법을 통해 주어진 배열을 정렬한다.

=================================================================================================
교통용어

DRT(Demand Responsive Transport) - 수요 응답형 교통체계, 교통 수요자의 요구에 따라 운행되는 교통체계, 교통 수요에 따라 가변적 운행 가능

MLFF(Mulit0Lane Free Flow) - 유료도로 통햅료 수납 시스템 중 하나로 여러 차로에서 무정차로 통행료를 수납하는 시스템을 말한다.
한국에서 다차로 하이패스 or 스마트톨링으로 불리는 시스템

ETCS - 하이패스

TACAN - 전술항행표지시설, 군용 항공기의 항법 시스템, 항공기에게 지상 기지국과의 거리 및 방위 정보를 제공하는 지상시설이다.

WIM(Weigh in Motion) - 축중기, 화물차량의 중량과 높이를 계측하는 장비, 화물차량이 허용 중량과 높이를 벗어나는 경우 도로 진입을 제한

BL - Black List, 도난, 분실, 연체 등의 사유로 거래정지가 된 신용카드의 목록을 말함, NL(Negative List)이라는 용어를 사용하기도 한다.

PL -  Positive List, 거래 승인이 가능한 신용카드 목록을 말한다.

C-ITS(Cooperative Intelligent Transport Systems, 협력 지능형 교통 체계) - 교통 체계가 통신을 통해 서로 협력하여 운영되는 시스템

OBU 미작동 :  OBU란, *(차량에 설치된 하이패스 단말기를 말함), 미납이 되면 고시서가 옴 -> 납부하면됨 (1년간 20회 이상의 미납이 발생시 10배부과)

AFC(Automatic Fare Collection) : 교통 관련 이용 요금을 자동으로 징수하는 시스템 (지하철을 이용할 때 출입구에 교통카드를 접촉시키면 자동으로 요금이 나가는 것과 같음)

스마트톨링 : 유료도로의 무정차 영업시스템, 영업소 차로에 근무원이 없고 ETCS만으로 운영되는 것이 특징, 통행한 차량의 결제 정보가 없으면 차량번호를 활용하여 차주에게 후불고지된다.

TCS - 수동 요금 징수 (사람 필요(현금))

=================================================================================================
에스트래픽 자주 쓰이는 용어[필수 단어 리스트]
HTTP 1.1/2/3
: HTTP 1.1 : 연결당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈가 존재
*특징 : 비연결지향(connectionless) : 클라이언트가 서버에 리소스 요청한 후 응답 받으면 연결을 끊어버리는 특징
서버에 부담을 주지 않도록 클라이언트 요청을 처리하면 연결을 끊어 서버의 부담을 줄인다. 하지만 리소스를 요청할 때마다 새롭게 연결해야 되므로 오버헤드 비용이 발생한다.
무상태성(stateless) : 각각의 요청은 독립적이라고 여겨지는 특성으로 서버는 클라이언트의 상태를 유지하지 않는다. 요청이 처리되면 연결이 끊어지기 때문에 클라이언트의 이전 상태를 알 수 없다.
*단점 : HOL(head of line) blocking: 특정 응답의 지연, 하나의 TCP 연결에서 3개의 이미지를 요청한 경우 첫 번째 이미지를 요청하고 응답이 지연되면 2,3번째 이미지는 대기하게 되는데 이러한 현상을 HTTP의 HOB(head of line blocking)이라고 부른다.

RTT(round trip time)증가 : 하나의 connection에 하나의 요청을 처리하면서 매 요청별로 connection이 연결되기 때문에 TCP 상에서 동작하는 HTTP 특성상 3-way handshake가 반복적으로 일어나 불필요한 RTT 증가와 네트워크 지연을 일으켜 성능을 저하시킨다.
 
무거운 header 구조 : 헤더에 많은 메타 정보를 저장한다. 매 요청시마다 중복된 header값을 전송하게 되며 해당 domain에 설정된 cookie 정보도 매 요청시 마다 헤더에 포함되어 전송된다.

*2줄 요약

: HTTP 2 :

: HTTP 3 :


아파치, 아파치 웹 서버, 아파치 톰캣, HTTPd
NginX
Tmax Zeus, Tmax WebToB, Tmax Tibero
Oracle, Oracle DB, Oracle RDBMS, Oracle WebLogic
Redis
RabbitMQ
TCP, UDP, QUIC
MNDB, IMDB
프로토콜이란?
IP와 IP 주소의 차이점
TCP/IP Layer와 TCP/IP Stack의 차이
프레임워크와 컴포넌트, 라이브러리 차이
Vue.js, React
Spring Framework, Spring Boot
jpg, png, bmp 구조와 특징, 차이
Telnet, SSH
FTP, SMB, NAS
SNMP
리눅스, 유닉스, 윈도우 차이
VMWare, VirtualBox, ESXi, Hyper-V 차이
API와 Restful API 차이
클래스, 메서드, 함수 차이
컴파일러, 인터프리터 차이
가비지 컬렉터와 자바의 가비지 켈럭터
CentOS, Ubuntu, RedHat, AIX

=================================================================================================

오라클은 유닉스/리눅스 환경에서 사용하는 관계형 데이터베이스 관리 시스템
MySQL은 오픈소스의 관계형 데이터베이스 관리 시스템
MSSQL은 윈도우 개발환경에서 사용하는 마이크로소프트가 개발한 관계형 데이터베이스 관리 시스템
MariaDB를 주로 사용, MySQl은 오픈소스 라이센스를 따르지만 상업적으로 사용할 때는 상업용 라이센스를 구매해야하고 MariaDB보다 속도가 떨어지기 때문에 
Mysql과 사용법도 비슷하고 여러가지 측면을 따졌을때 MariaDB가 선호되는 추세라고 판단되어 MariaDB를 경험했습니다.

자바의 클래스가 뭔가요
객체지향 언어에서 많이 사용하는 객체를 정의하는 틀 입니다.

자바의 메소드가 뭔가요
클래스가 전체 기능을 묶는 틀 이라면, 메소드는 기능의 동작을 묶는 틀 입니다.

REST가 뭔가요
web url로 http 통신을 하며 메소드(get, put, post, delete)를 사용하여 CRUD(Create, Read, Update, Delete)연산을 수행하는 서버 클라이언트 통신 방식입니다.

HTTP란 웹 상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜

REST 메소드인 Get과 Post의 차이가 뭔가요?

GET은 url에 정보를 포함하여 전송하고, 서버에서 어떤 데이터를 가져와서 보여줄 때 사용
POST는 정보를 HTTP Body에 포함하여 전송합니다. 서버상의 데이터 값이나 상태를 바꾸기 위해 사용

객체지향 언어(OOP)가 뭔가요?
객체지향 언어란 프로그램을 객체로 나누어 객체간 상호작용이 가능하게 하는 프로그래밍 언어 입니다.
기능이 아닌 객체가 중심이며 모듈의 재사용으로 확장 및 유지보수가 용이합니다.

패리티 비트가 뭔가요?
전송하고자 하는 데이터의 끝에 1비트를 더해 전송하는 방법으로 0과 1비트를 더해 데이터의 오류를 검출하는 오류식별자 입니다.

오버로딩 : 하나의 클래스에 같은 이름의 메서드를 여러개 정의하는 것, 매개변수의 유형과 개수가 다르도록 사용

오버라이딩 : 상위클래스를 하위클래스에서 호출하여 재정의 하는 것

오버로딩이나 오버라이딩을 활용하여 자바의 다형성을 지원함, 다형성이란 하나의 메서드나 클래스가 있을 때 그것이 다양한 방법으로 동작하는 것

Java의 접근 제어자 종류 : 
public - 접근제어 없음
private - 해당 클래스 내에서 접근 가능
protected - 같은 패키지 내에서와 다른 패키지의 자손 클래스에서 접근 가
default - 같은 패키지 내에서만 접근 가능

생성자란 : 클래스와 같은 이름의 메서드로, 새 객체가 생성될 때 호출되는 메서드 입니다.

자바 프로그램을 실행하게 되면 JVM(Java Virtual Machine)은 OS로부터 메모리를 할당받음
할당 받은 메모리를 자바 프로그램에 맞게 여러개의 영역으로 나누어 사용한다.

자바 메모리 구조
힙 : 사용자가 직접 관리하는 영역으로 실제 데이터가 동적으로 할당
스택 : 함수의 호출 정보, 기본자료형, 지역변수, 매개변수들이 저장
스태틱(메소드) : 클래스 변수나 static으로 선언된 것들이 저장됨 (class의 정보, static 변수, 생성자, 메소드 저장)

new 키워드로 인스턴스를 생성하면 Heap영역에는 생성된 객체가 저장, Stack 영역에서 생성된 객체에 대한 주소(Reference) 값이 저장됨
public class Variable { 

   public static int age = 20; // 클래스 변수(전역 변수)
    
    int height = 60; // 인스턴스 변수(전역 변수)
    
    public static void main(String[] args) { // 매개변수(파라미터)
       int size = 50; // 지역변수
        
    }
}

Animal a = new Animal("bird")
Animal("bird") : Heap Area
a : Stack Area

자바 equals() 는 객체간의 값(value)을 비교할 수 있고, == 은 대상의 주소(reference)를 비교합니다.
쉽게 말해서 ==는 int나 boolean에 사용하고, equals는 문자열 비교에 사용

TCP - 신뢰성 있는 통신에 사용, UDP보다 느림, 손상되면 재전송
UDP - 비 연결형 프로토콜, 순서 섞이고, 손상된 데이터 재전송 하지않음 주로 스트리밍 같은 곳에서 사용함

IP - 인터넷 망을 통해 패킷을 전달하는 프로토콜

트랜잭션 특징 ACID : A 원자성 C 일관성 I 격리성 D 지속성

NOSQL : Not Only SQL의 약자로 SQL을 보완한다는 의미를 가지고있고, 스키마가 없어서 속도가 빠르다.

스키마 : 데이터베이스의 구조와 제약조건에 대한 명세를 기술한 집합

객체지향 : 현실세계의 객체라는 개념을 이용한 프로그래밍

절차지향 : 수행되어야 할 연속적인 계산과 과정을 포함하고 있는 프로그래밍

Java와 Python 의 차이 : 사용 목적이 다르다고 생각합니다.

파이썬은 객체지향 언어이면서 스크립트 언어이기 때문에 컴파일 과정이 없어 속도가 느리다., AI개발 및 데이터 분석에 사용
C는 절차지향형 언어, 하드웨어 제어 시스템에 사용
C++은 객체지향, 게임 개발에 사용
Java는 웹 서비스 개발, 안드로이드 개발에 사용

객체지향 프로그래밍의 장점 : 코드 재사용성, 유지보수가 좋다
단점 : 속도가 느리다. 용량이 크다, 설계에 시간이 많이 소요된다.

스프링 프레임워크 : 자바 플랫폼을 위한 오픈 소스 어플리케이션 프레임워크 입니다. 동적인 웹 사이트를 개발하기 위해 서비스를 제공합니다.

MVC란 모델, 뷰, 컨트롤러로
모델은 알고리즘, DB와 같은 상호작용을 담당하고
뷰는 요청에 대한 처리 결과를 클라이언트에게 화면을 통해 보여줌
컨트롤러는 모델과 뷰 사이의 요청을 처리하고 흐름 제어를 담당

큐와 스택 : 스택은 가장 마지막에 삽입 되는 데이터가 가장 먼저 출력
큐는 가장 먼저 들어온 데이터가 먼저 나가는 구조

JPA란 ORM 기술로 객체와 데이터베이스의 데이터를 연결해주는 매핑 기술
ORM이기 때문에 자바 클래스와 DB테이블을 매핑한다.(SQL을 매핑하지않는다)

SQL - 관계형 데이터베이스의 데이터를 관리하기 위해 설계된 프로그래밍 언어
DDL : 데이터 정의 언어, Create, Drop, Alter
DML : 데이터 조작 언어, Select, Insert, Update, Delete
DCL : 데이터 제어 언어, Grant, Revoke

RPA :가상 소프트웨어 로봇을 사용해 시간이 많이 드는 수작업을 수행하는 자동화 기술입니다.

Was와 웹서버 차이점
Was는 웹 애플리케이션 서버로 주로 DB와 연결되어 사용 동적인 데이터를 위주로 처리하는것
웹 서버는 브라우저의 요청을 받아 결과를 웹 브라우저로 띄우는것, 정적 데이터 처리

비동기 방식에 대해 설명
비동기 방식이란 요청이 들어오면 다 끝내고 다음 요청을 받는 직렬형 동기 방식이 아닌, 
요청이 들어오면 해당 요청의 작업이 끝나지 않아도 계속 작업을 받아 처리하는 병렬형 구조

데이터베이스의 뷰
데이터를 보여주는 역할만 수행하는 가상 테이블

JSP는 Java Server Page로 HTML내에 직접 자바코드를 삽입하여 웹 서버에서 동적으로 웹 페이지를 생성하는 서버
Java는 서버쪽, JS는 클라이언트쪽 언어

자바 기초 문법
[]는 배열을 나타내는 데 사용됩니다. 
배열은 동일한 유형의 여러 요소를 저장하는 자료구조입니다.
 [] 안에는 배열의 크기를 나타내거나 비워둘 수도 있습니다. 
예를 들어, int[] numbers = new int[5];는 numbers라는 이름의 int 형식의 배열을 생성하고, 배열의 크기를 5로 설정합니다.

<>는 제네릭(Generic) 타입을 나타내는 데 사용됩니다. 
제네릭은 클래스 또는 인터페이스를 정의할 때, 타입 매개변수를 사용하여 클래스나 인터페이스가 다양한 유형의 객체를 다룰 수 있도록 합니다. 
예를 들어, ArrayList<String> list = new ArrayList<>();는 list라는 이름의 ArrayList 객체를 생성하며, 이 리스트는 문자열 타입의 요소를 저장할 수 있도록 정의됩니다.
[]는 배열의 크기를 나타내는 데 사용되고, <>는 제네릭 타입을 나타내는 데 사용됩니다. 이들은 서로 다른 문법적인 의미를 가지고 있으며, 다른 용도로 사용됩니다.

자바에서 배열과 리스트
배열 : Array, 배열은 정의와 동시에 길이를 지정해야하며 길이를 중간에 바꿀 수 없음
index를 통해 데이터에 접근 가능(Index는 데이터 식별자 역할), 정적이므로 크기를 초기에 지정해줘야함
int[] arr1 = new int [10];
정렬하기
int[] arr = {3,4,123,4534,1234,152,1};
Arrays.sort(arr);

리스트 : List, 배열과 다르게 빈 공간을 허용하지 않음
List에서의 Index는 데이터의 식별자가 아닌 몇 번째에 위치하였는지에 대한 의미만 갖는다.
동적으로 배열의 크기가 정해져있지 않다.
ArrayList<Integer> integers1 = new ArrayList<>();

List<Integer> list = new ArrayList<>();

list에 있는 데이터 개수 찾기
// size()
list.size();

리스트의 데이터를 가져올 때 사용
list.get(1);

data추가
// add(추가할 데이터)
// 위치 지정을 하고 싶다면 add(추가할 위치, 추가할 데이터);
list.add(10);
list.add(12);

데이터 수정 
// set(데이터 index, 변경할 값);
list.set(0, 15);

Element삭제
// remove(index값 또는 삭제할 값);
// remove method는 해당 index값을 삭제하고 값을 return한다.
// 값으로 삭제에 성공하면 true, 실패하면 false 리턴
list.remove("사과");

// 인덱스로 삭제에 성공하면 삭제한값을 리턴, 실패하면 false 리턴
list.remove(0);

// 값을 전체 다 삭제할 때는 clear(); 를 호출한다.
list.clear();


값 존재 유무 확인
// contains(찾고자 하는 값);
// contains는 값이 존재하는지에 대한 유무만을 return, true false 리턴해줌
list.contains(13);

// indexOf(찾고자 하는 값);
// indexOf는 찾고자 하는 값의 위치를 return해준다. (값이 없으면 -1 return)
list.indexOf(10);


배열이 비었는지 확인
// isEmpty();
// boolean type으로 return된다. 비어있으면 true, 비어있지 않으면 false
list.isEmpty();

Array와 List비교
Array는 데이터의 추가/삭제가 느리며 데이터 조회가 빠르다.
List는 데이터의 추가/삭제가 빠르며 데이터의 조회가 느리다.
데이터의 추가공간이 필요없이 크기가 정해져있고 추가적인 삽입/삭제 없이 검색을 필요로 할 때 유리하다.
데이터의 크기가 정해져있지 않고 데이터의 삽입/삭제가 많은 경우 유리하다.

크기 조정: 배열의 크기는 선언할 때 정해지고, 이후에는 변경할 수 없다. 반면에 List는 동적으로 크기를 조정할 수 있다. 요소를 추가하거나 제거할 때 List의 크기가 자동으로 조정되므로 편리하다.

삽입과 삭제: List는 요소의 삽입과 삭제가 쉽다. 요소를 삽입하려면 인덱스를 지정하고 값을 추가하면 되며, 요소를 삭제하려면 인덱스나 값으로 제거할 수 있습니다. 배열의 경우 요소를 삽입하거나 삭제하려면 많은 작업이 필요하다.

유연한 자료형: List는 여러 가지 자료형의 요소를 저장할 수 있다. 예를 들어, 정수, 문자열, 객체 등 다양한 유형의 데이터를 한 List에 저장할 수 있다. 하지만 배열은 하나의 자료형만 저장할 수 있다.

편리한 메서드: 자바의 List 인터페이스를 구현한 클래스들은 다양한 메서드를 제공한다. 예를 들어, 요소 검색, 정렬, 필터링 등의 작업을 쉽게 수행할 수 있다. 이러한 메서드를 사용하면 코드 작성과 유지보수가 간편해진다.

제네릭 타입: List는 제네릭 타입을 지원하므로, 컴파일 시에 타입 안정성을 보장할 수 있다. 타입 안정성을 유지하면 코드의 신뢰도와 유지보수성이 향상된다.

결론적으로, 자바에서 List를 사용하면 배열보다 유연하고 편리한 데이터 구조를 구현할 수 있다. List는 크기 조정, 삽입 및 삭제, 다양한 자료형 지원, 편리한 메서드, 제네릭 타입 등의 장점을 가지고 있어 많은 상황에서 배열보다 선호되는 선택이다.

자바의 Map은 파이썬의 딕셔너리와 유사한 구조로

리스트나 배열처럼 순차적으로 해당 요소 값을 구하지 않고 Key를 통해 Value를 얻는다.
많이 사용하는 방식

람다식 예제: 
 (1. 메서드) 
void PrintVal(String name, int i){
    System.out.println(name+"="+i); 
}
 (1. 람다식)
 (name, i) -> System.out.println(name+"="+i)

 (2. 메서드)
 int square(int x){
    return x*x
 }
 (2. 람다식)
 x -> x*x

 (3. 메서드)
 int roll(){
    return (int) (Math.random()*6);
 }
 (3. 람다식)
 () ->  { return (int) (Math.random()*6) }

 (4. 메서드)
 int sumArr(int[] arr){
    int sum = 0;
    for (int i : arr){
        sum+=i;
    }
    return sum;
 }
 (4. 람다식)
 (int[] arr) -> {int sum = 0;
    for (int i : arr){
        sum+=i;
    }
    return sum;
 }

public static void main(String[] args) {

        List<String> myList = new ArrayList<>();

        String course1 = "웹개발의 봄 Spring";
        String course2 = "프론트엔드의 꽃 React";

        // 리스트에 요소넣기 리스트.add()
        myList.add(course1);
        myList.add(course2);

        System.out.println(myList);

        // 리스트 요소 가져오기 리스트.get()
        System.out.println(myList.get(1));

        // 리스트 요소 지우기 리스트.remove()
        myList.remove(1);

        System.out.println(myList);

    }

* 자바 문자열 비교하기
compareTo() - 문자열의 사전순 값을 비교하여 그에 해당되는 int값을 리턴
예로 A > B 라고 가정하면,
- A = A  =  0 (동일한 경우) 
- A > B  =  1 (좌측 값이 큰 경우) 
- B > A  = -1 (좌측 값이 작은 경우) 

compare() - Comparator 인터페이스를 구현할 때 작성해야하는 메서드이다.
실제로 구현할 때 compare()에 2개의 인자를 넘겨 내부에 구현에 따라 int 결과 값을 리턴한다.

* 배열의 sort
public static void main(String[] args) {
        int[] intArr = {8,7,6,5,4};
        for(int i: intArr) 
            System.out.print(i + " ");
        System.out.println();
      //8 7 6 5 4

        Arrays.sort(intArr);
        for (int i : intArr) 
            System.out.print(i + " ");
        System.out.println();
      //4 5 6 7 8

        // String
        String[] strArr = {"d", "c", "b", "a"};
        for(String s: strArr) 
            System.out.print(s + " ");
        System.out.println();
        // d c b a

        Arrays.sort(strArr);
        for (String s : strArr) 
            System.out.print(s + " ");
        System.out.println();
      // a b c d

        Arrays.sort(strArr, Collections.reverseOrder());
        for (String s : strArr) 
            System.out.print(s + " ");
      // d c b a
    }

-HashMap 특징

1. 요소의 저장 순서를 유지하지 않습니다.

2. key :  중복을 허용  X 

   value :  중복은 허용 O

HashMap<String, String> map = new HashMap<String, String>();
map.put("people", "사람");
map.put("baseball", "야구");

get

key에 해당되는 값을 얻기 위해서는 다음과 같이 한다.
System.out.println(map.get("people"));
위와같이 get 메소드를 이용하면 value값을 얻을 수 있다. 위 예제는 결과로 "사람"이라는 문자열을 출력할 것이다.

containsKey

containsKey 메소드는 맵(Map)에 해당 키(key)가 있는지를 조사하여 그 결과값을 리턴한다.
System.out.println(map.containsKey("people"));
"people"이라는 키는 존재하므로 true가 출력될 것이다.

remove

remove 메소드는 맵(Map)의 항목을 삭제하는 메소드로 key값에 해당되는 아이템(key, value)을 삭제한 후 그 value 값을 리턴한다.
System.out.println(map.remove("people"));
"people"에 해당되는 아이템(people:사람)이 삭제된 후 "사람"이 출력될 것이다.

size
size 메소드는 Map의 갯수를 리턴한다.
System.out.println(map.size());

만약 입력된 순서대로 데이터를 가져오고 싶을때는 LinkedHashMap을 사용한다.
TreeMap은 입력된 key의 소트순으로 데이터가 출력되는 특징을 가지고 있다.

TreeMap은 키와 값을 한 쌍으로 하는 데이터를 이진 검색 트리의 형태로 저장한다.

* int와 Integer의 차이
int는 정수형 변수의 타입이고
Integer는 int 자료형을 객체로 다루기 위한 클래스 (Wrapper 클래스)
정수값만을 참조할 경우 int가 효율적이지만, 정수값을 객체로 사용하거나 메서드 및 속성의 사용이 필요한 경우 Integer 클래스를 사용한다.
double - Double
float - Float
long - Long
int - Integer
short - Short
byte - Byte
char - Character
boolean - Boolean

* 스트림이란
자바 8 API에 새로 추가된 기능으로 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다.
데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의가능
filter, map, reduce, find, match, sort 등으로 데이터를 조작가능

List<String> teenagerNames = members.stream()
        .filter(member -> member.getAge() < 20) // 내부 반복
        .map(Member::getName) // 파이프라이닝이 가능하다. 내부 반복
        .collect(toList());


    📃 클래스
객체를 나타내기 위한 자바의 도구(= 정보를 묶는 것)
클래스 내 정보를 멤버 변수라고 함
클래스명과 똑같은 이름을 가진 메소드를 생성자라고 함


public class Course {
    public String title;
    public String tutor;
    public int days;

      // 이렇게 아무런 파라미터가 없는 생성자를 기본생성자 라고 부릅니다.
    public Course() {

    }

    public Course(String title, String tutor, int days) {
           // this 는 "이것" 이죠? 클래스 변수를 가리킵니다.
        this.title = title;
        this.tutor = tutor;
        this.days = days;
    }
}


private으로 정의한 것을 어떻게 가져올까?
=> Getter / Setter를 이용하자!

Getter는 쉽게 말하면 정보를 가져오는 메소드

Setter는 정보를 바꾸는 메서드

### HTTP 요청 및 응답과 관련된 주요 클래스들과 메서드 설명

#### InputStreamReader: 2
InputStreamReader 클래스는 입력 스트림에서 바이트를 읽어 문자로 변환하는 데 사용됩니다.
BufferedReader와 함께 사용하여 서버 응답의 내용을 문자열 형태로 읽을 수 있습니다.
예제 코드에서 InputStreamReader는 connection.getInputStream()의 결과를 문자열로 읽기 위해 사용됩니다.

#### getInputStream(): 1 
getInputStream() 메서드는 HttpURLConnection 객체로부터 서버 응답 데이터를 읽기 위한 입력 스트림을 가져옵니다.
이 메서드를 호출하면 서버로부터 오는 응답 데이터를 읽을 수 있는 스트림을 얻게 됩니다.

#### DataOutputStream:3
DataOutputStream 클래스는 출력 스트림에 기본 데이터 타입을 쓰기 위해 사용됩니다.
예제 코드에서는 connection.getOutputStream()의 결과를 이용하여 요청 본문에 데이터를 쓰기 위해 사용됩니다.

#### OutputStream (추가 설명):
OutputStream 클래스는 바이트 기반의 출력 스트림을 나타내는 추상 클래스입니다.
HttpURLConnection의 getOutputStream() 메서드는 요청을 보낼 때 사용할 출력 스트림을 반환합니다.

어떤 방향으로 작성하는지 기억해야함

1. HttpURLConnection으로 restapi를 할 url과 연결함
2. DataOutputStream으로 보낼 데이터(출력)으로 데이터를 전송함
3. getInputStream으로 보낸 데이터의 결과값을 읽어들임
4. InputStreamReader으로 읽어들인 결과값을 문자로 변환함

OSI 7계층                     TCP/IP 4계층

L7 응용 계층 : SMTP, FTP, HTTP       L4 응용 계층 : TCP/UDP 기반의 응용 프로그램을 구현할 때 사용, FTP, HTTP, SSH
L6 표현 계층 : ASCII,GIF                  
L5 세션 계층 : API, SOCKET              
L4 전송 계층 : TCP, UDP                  L3 전송 계층 : 통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당, TCP, UDP
L3 네트워크 계층 : 라우터                 L2 인터넷 계층 : 통신 노드간의 IP 패킷을 전송하는 기능과 라우팅 기능을 담당, IP, ARP, RARP
L2 데이터링크 계층: 스위치 이더넷      L1 네트워크 계층 : 물리적인 주소로 MAC을 사용, LAN, 패킷망 등에 사용
L1 물리 계층 : 통신 케이블                

* ARP : ARP는 IP 주소를 MAC 주소로 변환해주기 위해 사용 되는 동적 매핑 프로토콜, 목적지 호스트 IP주소는 아는데, MAC주소(물리적 주소)를 모를 경우 사용

TCP/IP 통신은 실시간성 패킷 통신
RestAPI는 단방향 통신
WebSocket은 Restapi를 실시간성 통신하게 만들어주는 패킷 통신

자료구조 공부해가기 

자료구조가 메모리공간을 효율적으로 사용하는데 필요함

자료구조에는 선형 구조 선형, 비선형으로 나눠지는데

비선형에는 트리, 그래프가 존재한다.
선형에는 정적 자료구조인 배열과
동적 자료구조인 리스트, 큐, 스택이 있다.

스택은 LIFO 큐는 FIFO 선입선출
리스트는 순서가 있고, 삽입 삭제가 쉽고 검색이 느리고
배열은 순서가없고 중간에 데이터가 빠져도 그대로 냅둠, 삽입삭제가 어렵고 검색이 빠름

네트워크 통신과정
보내는쪽
응용계층에서 클라이언트에서 어디에 무엇을 보낼지를 OS에 부탁하고
전송계층에서 OS에서 어디에 보낼지 정보와 무엇을 보낼지에 관한 정보 등을 담아 소켓 형태로 담고 패킷으로 쪼갠다.
인터넷계층, 네트워크 계층에서 쪼개진 패킷을 서버에 전송한다.
받는쪽
서버에 도착하면 소켓을 다시 조립하고
재구성된 소켓에서 ip주소를 얻고 ARP로 MAC주소를 얻어낸다.

naver.com에 들어가기 위해 일어나는 일
평소에 네이버에 들어가봤는지, 캐시 서버와 호스트 서버에서 해당 URL(www.naver.com)의 IP주소를 찾아봅니다.

있다면 사용하고, 없다면 위의 과정을 통해 DNS 서버에 내가 가고자 하는 URL의 IP를 알려달라는 요청을 보냅니다.

해당 요청을 통해 받아온 IP주소로 웹사이트에 대한 데이터들을 달라는 요청을 받아온 IP 주소로 보냅니다.

받아온 데이터들을 렌더링하고 가공하여, 우리가 아는 네이버의 모습을 보여줍니다.

이 과정에서 DNS에서 IP를 받아오는 일, naver의 서버에서 데이터들을 받아오는 일들은
전부 위의 각각의 계층을 통과하는 네트워크 통신 과정을 통해 일어납니다.

물리: 보내는 쪽에서 전송한 전기 신호를 1계층 장비(허브, 케이블 등)가 재생성해서 2계층으로 전달
데이터: 2계층은 1계층으로부터 받은 전기 신호를 데이터 형태로 변환.
이 데이터에 있는 목적지가 내 랜카드의 MAC 주소랑 맞는지 확인하여 맞으면 3계층으로 데이터를 전달 아니면 폐기
네트워크:3계층은 2계층으로부터 받은 MAC주소랑 3계층의 IP주소를 확인해서 알맞은 단말기로 라우터가 최적의 경로를 찾아서 패킷을 전달
전송: 4계층은 3계층으로 부터 받은 패킷의 시퀀스, ACK 번호 및 포트번호를 확인해서 해당 패킷을 차단시키거나 통과시킴
세션: 5계층은 보내는 쪽과 받는 쪽을 연결하고 안정적으로 유지되도록 관리. 패킷 전송이 완료되면 연결을 끊는 역할을 수행
표현: 6계층은 받은 패킷을 자신의 시스템 또는 애플리케이션에 맞게 인코딩 또는 암호화 등을 하여 통일된 형식으로 변환
응용: 7계층은 6계층으로 부터 받은 통일된 형식의 데이터를 애플리케이션에서 사용

TCP의 연결은 3wayhandshake고 연결해졔는 4wayhandshake
1. 연결 요청
2. 응답 + 응답 대기
3. 응답 -> 연결

1. 연결 종료 요청
2. 응답 + 통신완 기다림
3. 통신 다되면 응답
4. 확인 응답

DNS는 도메인 이름과 ip주소를 변환하는 역할 ( 인터넷 전화번호부 )

JPA를 사용하려면 Entity나 DTO, VO의 개념을 잡아야한다.

Entity란 실제 데이터베이스 테이블과 1:1로 매핑되는 클래스로 데이터베이스 테이블내에 존재하는 컬럼만을 속성으로 가져야한다.

DTO란 view와 통신하기 위한 클래스, getter, setter 메서드 만을 가진 클래스 db에서 데이터를 받고 이 데이터를 스프링부트의 서비스나 컨트롤러 등으로 넘겨주는 역할
* 데이터베이스로부터 받을 데이터들을 어떤 방식, 타입등으로 보낼 것인지 정의해 놓는 클래스
ex) public class UserDTO {
    
    private String name;
    private String id;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
    
}

DAO란 레포지토리 패키지로 실제로 db에 접근하여 data를 crud하는 객체
서비스와 데이터베이스를 연결해주는 역할, 
*JPA에서는 DB에 데이터를 CRUD하는 Repository 객체들이 DAO라고 볼 수 있음. 완전히 같지는 않지만 개념차이로 실제로 개발할 때는 비슷하게 사용
*DAO의 경우 데이터베이스와 연결할 connection까지 설정되어 있는 경우가 많아, 현재 많이 쓰이는 Mybatis등을 사용할 경우 커넥션 풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드물다.

VO란 DTO와 혼용해서 쓰지만 미묘한 차이가 있다. VO는 값 오브젝트로써 값을 위해 쓰인다.
자바는 값 타입을 표현하기 위해 불변 클래스를 만들어서 사용하는데, 불변이라는 것은 readonly 특징을 가집니다.
*오직 Getter만 가능해야함, Setter 존재 x, 고정된 값을 사용하고 호출할 때 VO 사용
ex) class BookVO {
     private Long id;
     private String title;
     private String contents;

     @Override
     public boolean equals(Object o) {
           if (this == o) return true;
           if (o == null || getClass() != o.getClass()) return false;
           BookVO bookVO = (BookVO) o ;
           return Objects.equals(id, bookVO.id);
     }

     @Override
     public int hashCode() {
          return Objects.hash(id);
     }
}

자바의 인터페이스는 클래스를 작성할 때 기본이 되는 틀을 제공하면서 다른 클래스 사이의 매개 역할까지 담당하는 일종의 추상클래스
추상 클래스는 추상 메소드 뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있지만, 인터페이스는 오로지 추상 메소드와 상수만을 사용합니다.

둘의 가장 큰 차이로는 인터페이스는 틀만 쓰고, 추상 메소드는 확장해서 사용하는 느낌

싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다.
인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용한다.

URL과 URI의 차이점
URI는  자원자체를 식별하는 방법
URL은 자원이 어디있는지 위치를 알려주는 것

ex) http://www.naver.com/index.html?page=1232950&id=776
URI :  http://www.naver.com/index.html?page=1232950&id=776
URL : http://www.naver.com/index.html