시간복잡도는

빅 오메가, 빅 세타, 빅 오 표기법이 존재한다.

빅 오메가는 최선일 때의 연산 횟수를 나타내는것 ( 1 )
빅 세타는 보통일 때의 연산 횟수를 나타내는것 ( N/2 )
빅 오는 최악일 때의 연산 횟수를 나타낸다. ( N )

예를들어서 100개중 랜덤한 값을 하나 찾아야한다고 했을때, 0부터 값을 하나하나 넣어서 찾는다는 가정을 해보자.
최선의 연산 가정은 찾는값이 0일경우 1번에 찾는 것이고
보통일때는 50번(N/2)까지 넣었을 때 찾는 것이고
최악의 경우는 찾는값이 99로 모든 수를 다 넣었을때(N) 찾아지는 최악의 경우이다.

여기중에서 실제로 사용하는 방법은 빅-오 표기법을 사용한다.
코테의 경우 빅-오 표기법(O(n))을 기준으로 수행 시간을 계산하는 것이 좋습니다.

만약 코테에서 제한시간이 2초인경우 2억번 안의 계산으로 해결해야한다.

연산횟수 계산 방법은 = 알고리즘 시간복잡도 * 데이터의 크기이다.

대표적으로 n^2 시간복잡도를 사용하는 방법들과 n log2 (n)을 사용하는 시간복잡도를 계산해서 2억번보다 작게 나오면 그 알고리즘을 사용하면 된다.
*참고로 n log n 을 사용할 때 n log2(n) 이다.    log2 4 = 2

*버블 정렬(Bubble Sort):
시간복잡도 : O(n^2)

삽입 정렬(Insertion Sort):
시간복잡도 : O(n^2)

선택 정렬(Selection Sort):
시간복잡도 : O(n^2)

퀵 정렬(Quick Sort):
시간복잡도 : O(n^2) (이는 피벗(pivot) 선택에 따라 달라질 수 있습니다.)

*병합 정렬(Merge Sort):
시간복잡도 : O(n log2 (n))

힙 정렬(Heap Sort):
시간복잡도 : O(n log2 (n))

계수 정렬(Counting Sort):
시간복잡도 : O(n + k)
여기서 k는 입력 값의 범위를 의미합니다.

기수 정렬(Radix Sort):
시간복잡도 : O(d * (n + k))
여기서 d는 가장 긴 숫자의 자릿수를 의미하며, k는 각 자릿수의 범위를 의미합니다.

그리고 최종적으로 알고리즘을 다 짰을 때 제한시간에 걸리는지 내가 짠 알고리즘의 시간복잡도를 계산해봐야하는데 방법은
    1. 상수는 시간복잡도에서 제외한다.
        *연산횟수 =! 시간복잡도 (똑같은 반복문을 여러번 했어도 시간복잡도는 같다)
    2. 가장 많이 중첩된 반복문의 수행횟수가 시간복잡도의 기준이 된다.

실제 코딩테스트에서 시간 초과에 걸렸을 때 문제가 되는 부분을 빠르게 발견할 수 있다.

시간복잡도 사용
    1. 코딩테스트에서 문제를 보고 적합한 알고리즘 선택기준이 된다.
    2. 알고리즘 작성완료후 시간제한에 걸린다면 비효율적인 로직을 찾아서 개선한다.